-- Shareable event links: one token per project (creator can create/copy link).
create table if not exists public.project_share_links (
  id bigint primary key generated by default as identity,
  project_id bigint not null references public.projects(id) on delete cascade,
  token text not null unique,
  created_at timestamptz not null default now()
);

create index if not exists idx_project_share_links_token on public.project_share_links(token);
create index if not exists idx_project_share_links_project_id on public.project_share_links(project_id);

alter table public.project_share_links enable row level security;

-- Only project owner can manage share links.
create policy "Project owner can manage share_links"
  on public.project_share_links for all
  using (
    exists (
      select 1 from public.projects p
      where p.id = project_share_links.project_id and p.user_id = auth.uid()
    )
  )
  with check (
    exists (
      select 1 from public.projects p
      where p.id = project_share_links.project_id and p.user_id = auth.uid()
    )
  );

-- Authenticated users can read share_links (for RPC to resolve token).
create policy "Authenticated can read share_links"
  on public.project_share_links for select
  to authenticated
  using (true);

-- Event access: which users can view which projects (filled when they open share link).
create table if not exists public.event_access (
  project_id bigint not null references public.projects(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  created_at timestamptz not null default now(),
  primary key (project_id, user_id)
);

create index if not exists idx_event_access_user_id on public.event_access(user_id);

alter table public.event_access enable row level security;

create policy "Users can select own event_access"
  on public.event_access for select
  using (user_id = auth.uid());

create policy "Users can insert own event_access"
  on public.event_access for insert
  with check (user_id = auth.uid());

-- Allow projects SELECT for users who have event_access.
create policy "Users can view projects via event_access"
  on public.projects for select
  using (
    user_id = auth.uid()
    or exists (
      select 1 from public.event_access ea
      where ea.project_id = projects.id and ea.user_id = auth.uid()
    )
  );

-- Allow project_photos SELECT for users who have event_access to the project.
create policy "Users can view project_photos via event_access"
  on public.project_photos for select
  using (
    exists (
      select 1 from public.event_access ea
      where ea.project_id = project_photos.project_id and ea.user_id = auth.uid()
    )
  );

-- RPC: get event by token; upserts event_access and returns project + photos.
create or replace function public.get_event_by_token(share_token text)
returns json
language plpgsql
security definer
set search_path = public
as $$
declare
  pid bigint;
  proj json;
  photos json;
  result json;
begin
  if auth.uid() is null then
    raise exception 'Not authenticated';
  end if;

  select project_id into pid
  from public.project_share_links
  where token = share_token
  limit 1;

  if pid is null then
    raise exception 'Invalid or expired link';
  end if;

  insert into public.event_access (project_id, user_id)
  values (pid, auth.uid())
  on conflict (project_id, user_id) do nothing;

  select to_json(p.*) into proj
  from (
    select id, project_name, project_date, client_name, cover_url, created_at
    from public.projects
    where id = pid
  ) p;

  select coalesce(json_agg(pp.*), '[]'::json) into photos
  from (
    select id, project_id, url, filename, public_id, created_at
    from public.project_photos
    where project_id = pid
    order by created_at desc
  ) pp;

  result := json_build_object('project', proj, 'photos', photos);
  return result;
end;
$$;
