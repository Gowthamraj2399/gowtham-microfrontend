-- =============================================================================
-- studio-pro: Full Database Schema
-- Combined from all migrations (run this once on a fresh Supabase project)
-- =============================================================================


-- =============================================================================
-- 1. PROJECTS
-- Base table: one row per event/project, owned by the creator (user_id).
-- =============================================================================
create table if not exists public.projects (
  id                          bigint primary key generated by default as identity,
  user_id                     uuid not null references auth.users(id) on delete cascade,
  project_name                text,
  project_date                text,
  client_name                 text,
  cover_url                   text,
  album_size                  integer,                -- max photos per client album (null = unlimited)
  cloudinary_cloud_name       text,                  -- per-project Cloudinary cloud name
  cloudinary_upload_preset    text,                  -- per-project Cloudinary upload preset
  cloudinary_account_email    text,                  -- reference: which email the Cloudinary account uses
  created_at                  timestamptz not null default now()
);

create index if not exists idx_projects_user_id   on public.projects(user_id);
create index if not exists idx_projects_created_at on public.projects(created_at desc);

alter table public.projects enable row level security;

-- Project owners can manage their own projects (select, insert, update, delete).
create policy "Project owners can manage own projects"
  on public.projects for all
  using (user_id = auth.uid())
  with check (user_id = auth.uid());

-- Allow SELECT for users who have been granted event_access (added in migration 3).
create policy "Users can view projects via event_access"
  on public.projects for select
  using (
    user_id = auth.uid()
    or exists (
      select 1 from public.event_access ea
      where ea.project_id = projects.id and ea.user_id = auth.uid()
    )
  );


-- =============================================================================
-- 2. PROJECT PHOTOS
-- Metadata for images uploaded to Cloudinary (actual files live on Cloudinary).
-- =============================================================================
create table if not exists public.project_photos (
  id         uuid primary key default gen_random_uuid(),
  project_id bigint not null references public.projects(id) on delete cascade,
  url        text not null,
  filename   text not null,
  public_id  text,
  created_at timestamptz not null default now()
);

create index if not exists idx_project_photos_project_id on public.project_photos(project_id);
create index if not exists idx_project_photos_created_at on public.project_photos(created_at desc);

alter table public.project_photos enable row level security;

-- Project owner can view, insert, and delete their own project photos.
create policy "Users can view project_photos for own projects"
  on public.project_photos for select
  using (
    exists (
      select 1 from public.projects p
      where p.id = project_photos.project_id and p.user_id = auth.uid()
    )
  );

create policy "Users can insert project_photos for own projects"
  on public.project_photos for insert
  with check (
    exists (
      select 1 from public.projects p
      where p.id = project_photos.project_id and p.user_id = auth.uid()
    )
  );

create policy "Users can delete project_photos for own projects"
  on public.project_photos for delete
  using (
    exists (
      select 1 from public.projects p
      where p.id = project_photos.project_id and p.user_id = auth.uid()
    )
  );

-- Allow SELECT for users who have event_access to the project.
create policy "Users can view project_photos via event_access"
  on public.project_photos for select
  using (
    exists (
      select 1 from public.event_access ea
      where ea.project_id = project_photos.project_id and ea.user_id = auth.uid()
    )
  );


-- =============================================================================
-- 3. PROJECT SHARE LINKS
-- One shareable token per project; resolves to event_access on first visit.
-- =============================================================================
create table if not exists public.project_share_links (
  id         bigint primary key generated by default as identity,
  project_id bigint not null references public.projects(id) on delete cascade,
  token      text not null unique,
  created_at timestamptz not null default now()
);

create index if not exists idx_project_share_links_token      on public.project_share_links(token);
create index if not exists idx_project_share_links_project_id on public.project_share_links(project_id);

alter table public.project_share_links enable row level security;

-- Only project owner can manage (create / delete) share links.
create policy "Project owner can manage share_links"
  on public.project_share_links for all
  using (
    exists (
      select 1 from public.projects p
      where p.id = project_share_links.project_id and p.user_id = auth.uid()
    )
  )
  with check (
    exists (
      select 1 from public.projects p
      where p.id = project_share_links.project_id and p.user_id = auth.uid()
    )
  );

-- Any authenticated user can read share_links (needed for the RPC token resolution).
create policy "Authenticated can read share_links"
  on public.project_share_links for select
  to authenticated
  using (true);


-- =============================================================================
-- 4. EVENT ACCESS
-- Records which users have opened a share link and gained access to a project.
-- =============================================================================
create table if not exists public.event_access (
  project_id bigint not null references public.projects(id) on delete cascade,
  user_id    uuid   not null references auth.users(id) on delete cascade,
  created_at timestamptz not null default now(),
  primary key (project_id, user_id)
);

create index if not exists idx_event_access_user_id on public.event_access(user_id);

alter table public.event_access enable row level security;

create policy "Users can select own event_access"
  on public.event_access for select
  using (user_id = auth.uid());

create policy "Users can insert own event_access"
  on public.event_access for insert
  with check (user_id = auth.uid());


-- =============================================================================
-- 5. USER ALBUMS
-- One album per user per project; status: draft | submitted.
-- =============================================================================
create table if not exists public.user_albums (
  id           uuid primary key default gen_random_uuid(),
  user_id      uuid   not null references auth.users(id) on delete cascade,
  project_id   bigint not null references public.projects(id) on delete cascade,
  status       text   not null default 'draft' check (status in ('draft', 'submitted')),
  submitted_at timestamptz,
  created_at   timestamptz not null default now(),
  unique (user_id, project_id)
);

create index if not exists idx_user_albums_user_id   on public.user_albums(user_id);
create index if not exists idx_user_albums_project_id on public.user_albums(project_id);

alter table public.user_albums enable row level security;

create policy "Users can manage own albums"
  on public.user_albums for all
  using (user_id = auth.uid())
  with check (user_id = auth.uid());


-- =============================================================================
-- 6. USER ALBUM PHOTOS
-- Junction: which photos belong to which album.
-- =============================================================================
create table if not exists public.user_album_photos (
  album_id   uuid not null references public.user_albums(id) on delete cascade,
  photo_id   uuid not null references public.project_photos(id) on delete cascade,
  created_at timestamptz not null default now(),
  primary key (album_id, photo_id)
);

create index if not exists idx_user_album_photos_album_id on public.user_album_photos(album_id);

alter table public.user_album_photos enable row level security;

create policy "Users can manage own album photos"
  on public.user_album_photos for all
  using (
    exists (
      select 1 from public.user_albums ua
      where ua.id = user_album_photos.album_id and ua.user_id = auth.uid()
    )
  )
  with check (
    exists (
      select 1 from public.user_albums ua
      where ua.id = user_album_photos.album_id and ua.user_id = auth.uid()
    )
  );


-- =============================================================================
-- 7. NOTIFICATIONS
-- In-app notifications for creators (e.g. "album submitted").
-- =============================================================================
create table if not exists public.notifications (
  id         uuid primary key default gen_random_uuid(),
  user_id    uuid not null references auth.users(id) on delete cascade,
  type       text not null,
  title      text not null,
  body       text,
  payload    jsonb default '{}',
  read_at    timestamptz,
  created_at timestamptz not null default now()
);

create index if not exists idx_notifications_user_id   on public.notifications(user_id);
create index if not exists idx_notifications_read_at   on public.notifications(user_id, read_at);
create index if not exists idx_notifications_created_at on public.notifications(created_at desc);

alter table public.notifications enable row level security;

create policy "Users can view and update own notifications"
  on public.notifications for select
  using (user_id = auth.uid());

create policy "Users can update own notifications (mark read)"
  on public.notifications for update
  using (user_id = auth.uid())
  with check (user_id = auth.uid());

-- Any authenticated user can insert (caller inserts on behalf of the project owner).
create policy "Authenticated can insert notifications"
  on public.notifications for insert
  to authenticated
  with check (true);


-- =============================================================================
-- 8. USER ROLES
-- Simple RBAC: creator (studio owner) vs client (event viewer).
-- =============================================================================
create table if not exists public.user_roles (
  user_id    uuid primary key references auth.users(id) on delete cascade,
  role       text not null check (role in ('creator', 'client')),
  created_at timestamptz not null default now()
);

create index if not exists idx_user_roles_role on public.user_roles(role);

alter table public.user_roles enable row level security;

create policy "Users can select own role"
  on public.user_roles for select
  using (user_id = auth.uid());

create policy "Users can insert own role"
  on public.user_roles for insert
  with check (user_id = auth.uid());

create policy "Users can update own role"
  on public.user_roles for update
  using (user_id = auth.uid())
  with check (user_id = auth.uid());


-- =============================================================================
-- 9. RPC: get_event_by_token
-- Resolves a share token → upserts event_access → returns project + photos.
-- Final version includes: album_size, cloudinary_cloud_name, cloudinary_upload_preset.
-- =============================================================================
create or replace function public.get_event_by_token(share_token text)
returns json
language plpgsql
security definer
set search_path = public
as $$
declare
  pid    bigint;
  proj   json;
  photos json;
  result json;
begin
  if auth.uid() is null then
    raise exception 'Not authenticated';
  end if;

  select project_id into pid
  from public.project_share_links
  where token = share_token
  limit 1;

  if pid is null then
    raise exception 'Invalid or expired link';
  end if;

  insert into public.event_access (project_id, user_id)
  values (pid, auth.uid())
  on conflict (project_id, user_id) do nothing;

  select to_json(p.*) into proj
  from (
    select id, project_name, project_date, client_name, cover_url, created_at,
           album_size, cloudinary_cloud_name, cloudinary_upload_preset
    from public.projects
    where id = pid
  ) p;

  select coalesce(json_agg(pp.*), '[]'::json) into photos
  from (
    select id, project_id, url, filename, public_id, created_at
    from public.project_photos
    where project_id = pid
    order by created_at desc
  ) pp;

  result := json_build_object('project', proj, 'photos', photos);
  return result;
end;
$$;


-- =============================================================================
-- 10. RPC: submit_album
-- Marks an album as submitted and sends a notification to the project owner.
-- =============================================================================
create or replace function public.submit_album(album_uuid uuid)
returns void
language plpgsql
security definer
set search_path = public
as $$
declare
  rec             record;
  owner_id        uuid;
  project_title   text;
  submitter_email text;
  notif_title     text;
  notif_body      text;
begin
  if auth.uid() is null then
    raise exception 'Not authenticated';
  end if;

  select ua.id, ua.user_id, ua.project_id, p.user_id as owner_id, coalesce(p.project_name, 'Event') as title
  into rec
  from public.user_albums ua
  join public.projects p on p.id = ua.project_id
  where ua.id = album_uuid and ua.user_id = auth.uid();

  if rec.id is null then
    raise exception 'Album not found or access denied';
  end if;

  if rec.user_id is null or rec.owner_id is null then
    raise exception 'Invalid album or project';
  end if;

  update public.user_albums
  set status = 'submitted', submitted_at = now()
  where id = album_uuid and user_id = auth.uid();

  select email into submitter_email from auth.users where id = auth.uid();
  project_title := rec.title;
  notif_title := 'Album submitted';
  notif_body := coalesce(split_part(submitter_email, '@', 1), 'A guest') || ' submitted their photo selection for ' || project_title;

  insert into public.notifications (user_id, type, title, body, payload)
  values (
    rec.owner_id,
    'album_submitted',
    notif_title,
    notif_body,
    jsonb_build_object(
      'album_id', album_uuid,
      'project_id', rec.project_id,
      'submitted_by_user_id', auth.uid()
    )
  );
end;
$$;


-- =============================================================================
-- 11. RPC: get_creator_submissions
-- Returns all projects owned by the caller that have at least one submitted album.
-- =============================================================================
create or replace function public.get_creator_submissions()
returns json
language plpgsql
security definer
set search_path = public
as $$
declare
  result json;
begin
  if auth.uid() is null then
    raise exception 'Not authenticated';
  end if;

  select coalesce(
    json_agg(
      json_build_object(
        'project_id', p.id,
        'project_name', p.project_name,
        'albums', sub.albums
      )
      order by (select max((a->>'submitted_at')::timestamptz) from json_array_elements(sub.albums) as a) desc nulls last
    ),
    '[]'::json
  ) into result
  from (
    select ua.project_id, json_agg(
      json_build_object(
        'album_id', ua.id,
        'submitted_at', ua.submitted_at,
        'submitted_by_user_id', ua.user_id
      )
      order by ua.submitted_at desc
    ) as albums
    from public.user_albums ua
    where ua.status = 'submitted'
      and exists (
        select 1 from public.projects p
        where p.id = ua.project_id and p.user_id = auth.uid()
      )
    group by ua.project_id
  ) sub
  join public.projects p on p.id = sub.project_id;

  return result;
end;
$$;


-- =============================================================================
-- 12. RPC: get_submitted_album_with_photos
-- Returns a submitted album + its photos for a project owned by the caller.
-- Final version includes cloudinary_cloud_name on the project object.
-- =============================================================================
create or replace function public.get_submitted_album_with_photos(p_album_id uuid)
returns json
language plpgsql
security definer
set search_path = public
as $$
declare
  rec    record;
  proj   json;
  alb    json;
  photos json;
  result json;
begin
  if auth.uid() is null then
    raise exception 'Not authenticated';
  end if;

  select ua.id, ua.submitted_at, ua.user_id as submitted_by_user_id,
         p.id as project_id, p.project_name, p.project_date, p.client_name, p.cover_url,
         p.cloudinary_cloud_name
  into rec
  from public.user_albums ua
  join public.projects p on p.id = ua.project_id
  where ua.id = p_album_id
    and ua.status = 'submitted'
    and p.user_id = auth.uid();

  if rec.id is null then
    return null;
  end if;

  proj := json_build_object(
    'id', rec.project_id,
    'project_name', rec.project_name,
    'project_date', rec.project_date,
    'client_name', rec.client_name,
    'cover_url', rec.cover_url,
    'cloudinary_cloud_name', rec.cloudinary_cloud_name
  );

  alb := json_build_object(
    'id', rec.id,
    'submitted_at', rec.submitted_at,
    'submitted_by_user_id', rec.submitted_by_user_id
  );

  select coalesce(json_agg(pp.*), '[]'::json) into photos
  from (
    select pp2.id, pp2.url, pp2.filename, pp2.public_id
    from public.user_album_photos uap
    join public.project_photos pp2 on pp2.id = uap.photo_id
    where uap.album_id = p_album_id
    order by uap.created_at
  ) pp;

  result := json_build_object('project', proj, 'album', alb, 'photos', photos);
  return result;
end;
$$;


-- =============================================================================
-- 13. RPC: reopen_submitted_album
-- Sets a submitted album back to draft so the client can update and resubmit.
-- Only the project owner can call this.
-- =============================================================================
create or replace function public.reopen_submitted_album(p_album_id uuid)
returns void
language plpgsql
security definer
set search_path = public
as $$
begin
  if auth.uid() is null then
    raise exception 'Not authenticated';
  end if;

  update public.user_albums ua
  set status = 'draft', submitted_at = null
  from public.projects p
  where ua.id = p_album_id
    and ua.project_id = p.id
    and p.user_id = auth.uid()
    and ua.status = 'submitted';

  if not found then
    raise exception 'Album not found or not allowed to reopen';
  end if;
end;
$$;
